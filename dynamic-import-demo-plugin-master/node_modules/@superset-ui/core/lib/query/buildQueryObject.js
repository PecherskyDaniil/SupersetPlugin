"use strict";

exports.__esModule = true;
exports.default = buildQueryObject;
exports.DTTM_ALIAS = void 0;

var _processGroupby = _interopRequireDefault(require("./processGroupby"));

var _convertMetric = _interopRequireDefault(require("./convertMetric"));

var _processFilters = _interopRequireDefault(require("./processFilters"));

var _extractExtras = _interopRequireDefault(require("./extractExtras"));

var _extractQueryFields = _interopRequireDefault(require("./extractQueryFields"));

var _processExtraFormData = require("./processExtraFormData");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

const DTTM_ALIAS = '__timestamp';
/**
 * Build the common segments of all query objects (e.g. the granularity field derived from
 * either sql alchemy or druid). The segments specific to each viz type is constructed in the
 * buildQuery method for each viz type (see `wordcloud/buildQuery.ts` for an example).
 * Note the type of the formData argument passed in here is the type of the formData for a
 * specific viz, which is a subtype of the generic formData shared among all viz types.
 */

exports.DTTM_ALIAS = DTTM_ALIAS;

function buildQueryObject(formData) {
  const {
    annotation_layers = [],
    extra_form_data = {},
    time_range,
    since,
    until,
    order_desc,
    row_limit,
    row_offset,
    limit,
    timeseries_limit_metric,
    queryFields,
    granularity,
    url_params = {}
  } = formData,
        residualFormData = _objectWithoutPropertiesLoose(formData, ["annotation_layers", "extra_form_data", "time_range", "since", "until", "order_desc", "row_limit", "row_offset", "limit", "timeseries_limit_metric", "queryFields", "granularity", "url_params"]);

  const {
    append_form_data = {},
    override_form_data = {}
  } = extra_form_data;
  const numericRowLimit = Number(row_limit);
  const numericRowOffset = Number(row_offset);
  const {
    metrics,
    groupby,
    columns
  } = (0, _extractQueryFields.default)(residualFormData, queryFields);
  const groupbySet = new Set([...columns, ...groupby]);
  const extras = (0, _extractExtras.default)(formData);
  const extrasAndfilters = (0, _processFilters.default)(_extends({}, formData, {}, extras));

  let queryObject = _extends({
    time_range,
    since,
    until,
    granularity
  }, extras, {}, extrasAndfilters, {
    annotation_layers,
    groupby: (0, _processGroupby.default)(Array.from(groupbySet)),
    is_timeseries: groupbySet.has(DTTM_ALIAS),
    metrics: metrics.map(_convertMetric.default),
    order_desc: typeof order_desc === 'undefined' ? true : order_desc,
    orderby: [],
    row_limit: row_limit == null || Number.isNaN(numericRowLimit) ? undefined : numericRowLimit,
    row_offset: row_offset == null || Number.isNaN(numericRowOffset) ? undefined : numericRowOffset,
    timeseries_limit: limit ? Number(limit) : 0,
    timeseries_limit_metric: timeseries_limit_metric ? (0, _convertMetric.default)(timeseries_limit_metric) : null,
    url_params
  }); // append and override extra form data used by native filters


  queryObject = (0, _processExtraFormData.appendExtraFormData)(queryObject, append_form_data);
  queryObject = (0, _processExtraFormData.overrideExtraFormData)(queryObject, override_form_data);
  return queryObject;
}